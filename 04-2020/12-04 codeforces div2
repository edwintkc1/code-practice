// codeforces 263A
// #33
// input a 5x5 matrix, with 24 zeros and 1 one. Someont think that if that 1 in the middle of matrix, it means beautiful.
// you can move the 1 by swithcing its col or row. Count the least time you need in order to swith it to the middle.
// input: 0 0 0 0 0
          0 0 0 0 1
          0 0 0 0 0
          0 0 0 0 0
          0 0 0 0 0
// output:3

// just count the difference of coordiante 1 and middle(3,3)

#include <iostream>
#include <cmath>
using namespace std;

int matrix[5][5] = { 0 };
int x, y, ans;
int main() {
	for (int i = 1; i <= 5; i++)
		for (int j = 1; j <= 5; j++) 
			cin >> matrix[i][j];
		
	for(int i =1;i<=5;i++)
		for(int j=1;j<=5;j++)
			if (matrix[i][j] == 1) {
				x = i;
				y = j;
			}
	ans = abs(3 - x) + abs(3 - y);
	cout << ans;

	return 0;
}

----------------------------------------------------------------------------------------------------------------------
// codeforces 266B
// #34
// queue in school. input n and k , n = number of children, k = after k second. Also input a string with B and G,
// represent the gender of n children.
// in current second, if i position is a B, and i-1 position is a G, change it in the next second.

// when it comes to even second, no changes
// just use the condition 

#include <iostream>
using namespace std;

int n, t;
string input;
int main() {
	cin >> n >> t >> input;
	while (t--) {
		for (int i = 1; i < n; i++) {
			if (input[i] == 'G' && input[i - 1] == 'B') {
				input[i] = 'B';
				input[i - 1] = 'G';
				i++;
			}
		}
	}
	cout << input;
	return 0;
}

----------------------------------------------------------------------------------------------------------------------
// codeforces 32B
// #35
// 摩斯密碼,   .  represent 0 ,  .- represent 1,   -- represent 2
// input a code, decode it as number
// input: .-.--
// output:012
// input: --.
// output:20

#include <iostream>
using namespace std;

string s, ans;
int i;
int main() {
	cin >> s;
	while (i != s.length()) {
		if (s[i] == '.') {
			ans += '0';
			i++;
		}
		if (s[i] == '-' && s[i + 1] == '.') {
			ans += '1';
			i+=2;
		}
		if (s[i] == '-' && s[i + 1] == '-') {
			ans += '2';
			i+=2;
		}
	}
	cout << ans;
	return 0;
}

----------------------------------------------------------------------------------------------------------------------
// codeforces 271A
// #36
// We say the year is a beautiful year when all number of the year are different.
// 1000<=year<=9000
// input a year, output the next beautiful year
// input: 1987
// output:2013

#include <iostream>
using namespace std;

int input;
int a, b, c, d;
int main() {
	cin >> input;
	while (true) {
		input += 1;
		a = input / 1000, b = input / 100 % 10, c = input / 10 % 10, d = input % 10;
		if (a != b && a!=c && a!=d && b != c && b!= d && c != d) {
			break;
		}
	}
	cout << input;
	
	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// codeforces 59A
// #37
// input a string, change it to uppercase or lowercase by given condition
// if lowercase of the input is >= uppercase, change all char into lowercase
// if upper > lower, change all the char into uppercase
// 2 special case, vip and house, given in the question, need to change it to specific string


#include <iostream>
using namespace std;

string input;
int countUpper = 0, countLower = 0;

int main() {
	cin >> input;
	if (input == "HoUse") {
		cout << "house";
		return 0;
	}
	if (input == "ViP") {
		cout << "VIP";
		return 0;
	}
	for (int i = 0; i < input.length(); i++) {
		if (input[i] >= 'a' && input[i] <= 'z') {
			countLower++;
		}
		if (input[i] >= 'A' && input[i] <= 'Z') {
			countUpper++;
		}
	}
	if (countLower >= countUpper ) {
		for (int i = 0; i < input.length(); i++) {
			input[i] = tolower(input[i]);
		}
	}
	else if (countUpper > countLower) {
		for (int i = 0; i < input.length(); i++) {
			input[i] = toupper(input[i]);
		}
	}
	cout << input;
	return 0;
}

----------------------------------------------------------------------------------------------------------------------
// codeforces 110A
// #38
// input a number, if it contain 4 or 7, count ++, if count finally achieve 4 or 7, output yes, otherwise, output no
// input: 7747774
// output:YES
// input: 40047
// output:NO

#include <iostream>
using namespace std;

string input;
int cnt = 0;
int main() {
	cin >> input;
	for (int i = 0; i < input.length();i++) {
		if (input[i] == '4' || input[i] == '7')
			cnt++;
	}
	if (cnt == 4 || cnt == 7)
		cout << "YES";
	else
		cout << "NO";
	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// codeforces 266A
// #39
// input a string represent stones with different colours, R = red , B = blue, etc.
// we need to take away any two neighboring stones if their colours are the same
// count how many stone(s) need to be taken away.
// input: 3
	  RRG
// output:1
// input: 5
	  RRRRR
// output:4

#include <iostream>
using namespace std;

int main() {
	int n, count=0, lastValidIndex = 0;
	string s;
	cin >> n >> s;
	for (int i = 1; i < s.length(); i++) {
		if (s[i] == s[lastValidIndex] || s[i] == s[i + 1])
			count++;
		else
			lastValidIndex = i;
	}
	cout << count;
	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// codeforces 80A
// #40
// input 2 number, n and m, check if m is the next prime number of n.
// if yes, cout YES, no, cout NO
// input: 3 5
// output:YES
// input: 7 9
// output:NO

// first generate a array containing prime number in the given boundary
// find the index of n
// if statement, if next index of index n == m, cout yes

#include <iostream>
using namespace std;

int main() {
	int n, m, index = 0, arr[100] = { 0 };
	int i, j;
	for (i = 2; i < 100; i++) {
		for (j = 2; j <=i ; j++) {
			if (i % j == 0)
				break;
		}
		if (j == i) {
			arr[index] = i;
			index++;
		}
	}
	cin >> n >> m;
	int indexN;
	for (int i = 0; i < 100; i++) {
		if (arr[i] == n) {
			indexN = i;
			break;
		}
	}
	if (arr[indexN] == n && arr[indexN + 1] == m)
		cout << "YES";
	else
		cout << "NO";

	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// codeforces 61A
// #41
// input 2 number, if i digit in s1 == i digit in s2, then i digit in ans = 1, otherwise i digit in ans = 0
// input: 1010100
	  0100101
// output:1110001

#include <iostream>
using namespace std;

int main() {
	string s1, s2, ans="";
	cin >> s1 >> s2;
	for (int i = 0; i < s1.length(); i++) {
		if (s1[i] != s2[i])
			ans += '1';
		else
			ans += '0';
	}
	cout << ans;
	
	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// codeforces 144A
// #42
// input n, and data of n number. You need to make the maximum number in those data to be the first data
// and the minimum number in those data be the last data. You could swap any two neighboring number
// count the least swap times you need
// 將最大嘅數移到最前，最細嘅數移到最後
// input: 4
	  33 44 11 22
// output:2
// input: 7
	  10 10 58 31 63 40 76
// output:10

// 1. find the index of maximum and minimum data
//    tricky part:cuz you need to move the maximum number to the front
//    the index of maximum need to be as small as possible
//    if there is a data equals to (=) the current max, no need to change
//    as for minimum, we need to move it to the end
//    then the index of it is as large as possible, when it comes to equal, we need to change its index
// 2. count how many times you need
//    if the max index > min index, as the max need to move to front
//    during the process, you'll also move the min index 1 times forward.
//    so subtract total time by 1

#include <iostream>
using namespace std;

int main() {
	int n, x[101];
	int max = INT_MIN, min=INT_MAX;
	int indexMax= 0 , indexMin=0;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x[i];
		if (x[i] > max) {
			max = x[i];
			indexMax = i;
		}
		if (x[i] <= min) {
			min = x[i];
			indexMin = i;
		}

	if (indexMax > indexMin) 
		cout << indexMax - 1 + n - indexMin - 1;
	else
		cout << indexMax - 1 + n - indexMin;

	return 0;
}





