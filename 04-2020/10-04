// 洛谷
// #31
// check the ISBN number correct or not. A ISBN number contain 13 char, if all number * x = the last ISBN number % 11
// cout rirght, else, rectify the ISB number and ouput the correct one
// after using x, x increaced by 1 each time.
// special case: if the last ISBN number % 11 is 10, the last ISBN number would be 'X', not 10
// input: 0-670-82162-4
// output: Right
// input: 0-670-82162-0
// output:0-670-82162-4

// 1. sum (validate number * x), when it comes to '-', continue
// 2. if correct, cout Right, if not, split it into 2 cases
//    case 1: cout X, case 2: correct it and ouput the right one

#include <iostream>
using namespace std;

char input[14] = { 0 };
int sum = 0, x = 1;

void solution() {
	for (int i = 0; i < 12; i++) {
		if (input[i] == '-')
			continue;
		sum += (input[i] - '0') * x++;
	}

	if (sum % 11 == input[12] - '0') 
		cout << "Right";
	else {
		if (sum % 11 == 10 && input[12] == 'X') {
			cout << "Right";
			return;
		}
		input[12] = sum % 11 + '0';
		if (sum % 11 == 10)
			input[12] = 'X';
		cout << input;
	}
}

int main() {
	cin.getline(input,14);
	solution();
	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// 洛谷
// #32
// Goldbach conjecture,哥德巴赫猜想
// any integer (> 2) could be added by 3 prime number
// now input a number, then ouput the 3 prime number
// input: 2009
// output: 3 3 2003

//1. 打表, put all prime number (<=input number) into a temp array
//2. use 3 for loop to test, if get a solution, break


#include <iostream>
using namespace std;

int input = 0, temp[1000] = { 0 };

void solution() {
	int count = 0, i, j, index=0;
	for (i = 2; i <= input; i++) {
		for (j = 2; j <= i; j++) {
			if (i % j == 0) 
				break;
		}
		if (j == i) {
			temp[count] = i;
			count++;
		}
	}
	for (int i = 0; i < count; i++)
		for (int j = 0; j < count; j++)
			for (int k = 0; k < count; k++)
				if (temp[i] + temp[j] + temp[k] == input) {
					cout << temp[i] << " " << temp[j] << " " << temp[k];
					return;
				}

}

int main() {
	cin >> input;
	solution();
	return 0;
}
----------------------------------------------------------------------------------------------------------------------
// 洛谷
// #33
// remove the light
// input n light, maximum distance that the light could cover, and places (number) of each light
// we need to remove some light to save the energy
// if the distance of 2 adjacent lights <= maximum distance that the light could cover
// delete that light, count how many light need to be deleted, ouput number of deleted lights
// input: 3 3
//        1 2 3
// output:1

// 1. use array to stroe position of lights
// 2. sort it, sort(address, address)
// 3. if statement, and remove that light

#include <iostream>
#include <algorithm>
using namespace std;

int main() {
	int n, distance, deleted= 0, light[100001] = { 0 };
	cin >> n >> distance;
	for (int i = 0; i < n; i++)
		cin >> light[i];
	sort(light, light + n);       // sort algorithm need address, the end address should be first address + how many element in the array

	for (int i = 1; i < n - 1; i++) {                 //cuz the first light and the last light must be turned on, skip them
		if (light[i + 1] - light[i - 1] <= distance) {
			light[i] = light[i - 1];         //we need to delete light[i], so after remove that light.
			deleted++;                       //move the light before it to its place, otherwise we still consider it is a light next time
		}
	}
	cout << deleted;
	return 0;
}
