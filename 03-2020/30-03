// 雜題
// #25   asm q6

#include <iostream>
using namespace std;

bool success = false;
int walk(int, int, int, int);
int** maze;


int main() {
	int size,current[2] = { 0,0 };
	int x = 0, y = 0, endX, endY;                      //start point and end point

	cout << "Input the size of the maze:\n";
	cin >> size;
	cout << "Input the coordinate of the exit:\n";
	cin >> endX >> endY;
	maze = new int* [size];                                      
	for (int i = 0; i < size; i++)
		maze[i] = new int[size];
	cout << "Input the structure of the maze:\n";
	for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
			cin >> maze[i][j];


	cout << "\n\n";
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			cout << maze[i][j] << " ";
		}
		cout << endl;
	}
	if (walk(x, y, endX, endY) == 0)
		cout << "There is no way to get to the exit!\n";        //return value = 0 means no road
	else
		cout << "Congratulation! You can get to the exit!\n";//return value != 0 means could get to the exit
	


	return 0;
}

int walk(int x, int y, int endX, int endY) {
	maze[i][j] = -1;

	if (x == endX && y == endY)
		return 1;
	if (maze[x][y - 1] == 1)      //left
		walk(x, y - 1, endX, endY);
	if (maze[x - 1][y] == 1)      //up
		walk(x - 1, y, endX, endY);
	if (maze[x][y + 1] == 1)     //right
		walk(x, y + 1, endX, endY);
	if (maze[x + 1][y] == 1)     //down
		walk(x + 1, y, endX, endY);

	if (x != endX && y != endY)
		maze[x][y] = 0;
	return 0;
}





//test
//1 0 0 1 0
//1 1 1 1 0
//0 1 1 0 1
//0 0 0 0 1
//0 1 1 1 1
