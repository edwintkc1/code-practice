// 雜題
// #25   rat in the maze， 01 maze,  use depth first search (dfs), classic recursion problem
// input size of 2D array (size * size), it is a maze, then assign value to it
// 1 means the rat could go through that road, 0 means could not
// if the rat could go to exit finally, ouput yes, otherwise, ouput no.
// input: 5
//        4 4
// 	  1 0 0 1 0
	  1 1 1 1 0
	  0 1 1 0 1
	  0 0 0 0 1
	  0 1 1 1 1
// output:There is no way to get to the exit!
// input: 7
//	  5 0
//        1 0 0 1 0 0 1
	  1 1 1 1 0 1 1
	  0 1 0 1 1 0 1
	  0 0 0 0 1 1 1
	  0 1 1 1 1 0 0
	  1 1 0 0 0 1 0
	  0 0 1 1 1 1 1
// output:Congratulation! You can get to the exit!

#include <iostream>
using namespace std;

bool success = false;
int walk(int, int, int, int, int);
int** maze, ** visited;
int direction = 0;                                      // 1 = right, 2 = left, 3 = up, 4 = down

bool inBoundary(int x, int y, int size)
{
	if (x >= 0 && y >= 0 && x < size && y < size) {
		return true;
	}
	return false;
}

int main() {
	int size, current[2] = { 0,0 };
	int x = 0, y = 0, endX, endY;                      //start point and end point
	cout << "Input the size of the maze:\n";
	cin >> size;
	cout << "Input the coordinate of the exit:\n";
	cin >> endX >> endY;

	maze = new int* [size];
	for (int i = 0; i < size; i++)
		maze[i] = new int[size];
	cout << "Input the structure of the maze:\n";
	for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
			cin >> maze[i][j];

	visited = new int* [size];
	for (int i = 0; i < size; i++)
		visited[i] = new int[size];
	for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
			visited[i][j] =  0 ;

	//cout << "\n\n";
	//for (int i = 0; i < size; i++) {
	//	for (int j = 0; j < size; j++) {
	//		cout << maze[i][j] << " ";
	//	}
	//	cout << endl;
	//}
	if (walk(x, y, endX, endY, size) == 1)
		cout << "There is no way to get to the exit!\n";        //return value = 0 means no road
	else
		cout << "Congratulation! You can get to the exit!\n";//return value != 0 means could get to the exit



	return 0;
}


int walk(int x, int y, int endX, int endY, int size) {
	if (x == endX && y == endY) {
		return 1;
	}
	else {
		visited[x][y] = 1;

		if (maze[x][y + 1] == 1 && visited[x][y + 1] == 0) {     //right
			walk(x, y + 1, endX, endY, size);
		}
		if (maze[x + 1][y] == 1 && visited[x + 1][y] == 0) {     //down
			walk(x + 1, y, endX, endY, size);
		}
		if (maze[x][y - 1] == 1 && visited[x][y - 1] == 0) {      //go left
			walk(x, y - 1, endX, endY, size);
		}
		if (x != 0) {
			if (maze[x - 1][y] == 1 && visited[x - 1][y] == 0) {      //up
				walk(x - 1, y, endX, endY, size);
			}
		}
		maze[x][y] = 0;
		return 0;
	}
	return 0;
}

