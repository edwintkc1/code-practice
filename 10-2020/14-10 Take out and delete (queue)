#include <iostream>
#include <utility>
#define SIZE 1005
using namespace std;

class queue
{
public:
	int front, rear;
	pair<int, int> p[SIZE];

	queue() {
		front = 0;
		rear = 0;
		for (int i = 0; i < SIZE; i++) {
			p[i] = make_pair(-1005, -1005);
		}
	}

	bool isEmpty() {
		return(front == rear);
	}

	bool isFull() {
		return((rear + 1) % SIZE == front);
	}

	void enqueue(pair<int,int> temp) {
		if (!isFull()) {
			p[rear] = temp;
			rear = (rear + 1) % SIZE;
		}
	}

	pair<int,int> dequeue() {
		if (!isEmpty()) {
			pair<int, int> temp = p[front];
			front = (front + 1) % SIZE;
			return temp;
		}
	}

	void clear() {
		front = 0;
		rear = 0;
		for (int i = 0; i < SIZE; i++) {
			p[i] = make_pair(-1005, -1005);
		}
	}
};


int main()
{
	int T;
	cin >> T;

	queue myQueue;
	while (T--) {
		int N, K;
		cin >> N >> K; // N = N numbers,  K = take out how many numbers each time

		int index = 1; // for the number's index
		while (N--) {
			int data;
			cin >> data;
			pair<int, int> temp = make_pair(data, index++);
			myQueue.enqueue(temp);
		}

		while (myQueue.isEmpty() != true)
		{
			pair<int, int> temp[20];
			for (int i = 0; i < 20; i++)
				temp[i] = make_pair(-1005, -1005);


			while (myQueue.isEmpty() == false) {
				for (int i = 0; i < K; i++) {
					temp[i] = myQueue.dequeue();
					if (myQueue.isEmpty())
						break;
				}

				// find the max one
				int max = -1006, maxIndex = 0;
				for (int i = 0; i < K; i++) {
					if (temp[i].first > max)
					{
						max = temp[i].first;
						maxIndex = i;
					}
				}
				// delete the max, simply set both to 0
				cout << temp[maxIndex].second;
				temp[maxIndex] = make_pair(-1005, -1005);

				// decrease the rest K-1 elements by 1
				// insert back to the queue
				for (int i = 0; i < K; i++)
				{
					if (temp[i].first != -1005) {
						temp[i].first--;
						myQueue.enqueue(temp[i]);
						temp[i] = make_pair(-1005, -1005);
					}
				}
				if(myQueue.isEmpty() == false)
					cout << ' ';
			}
		}
		cout << endl;
		myQueue.clear();
	}
	return 0;
}
