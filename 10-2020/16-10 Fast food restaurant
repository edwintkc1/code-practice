#include <iostream>
#define SIZE 100005
using namespace std;

class queue
{
public:
	int front, rear;
	int arr[SIZE];

	queue()
	{
		front = 0;
		rear = 0;
		for (int i = 0; i < SIZE; i++)
			arr[i] = 0;
	}

	bool isEmpty()
	{
		return (front == rear);
	}

	void push(int i)
	{
		arr[rear] = i;
		rear = (rear + 1) % SIZE;
	}

	void pop()
	{
		front = (front + 1) % SIZE;
	}

	int back()
	{
		return arr[rear - 1];
	}

	int getFront()
	{
		return arr[front];
	}

	int size()
	{
		return (rear - front);
	}

	void clear()
	{
		front = 0;
		rear = 0;
		for (int i = 0; i < SIZE; i++)
			arr[i] = 0;
	}

};

int main() {
	int N;
	while (cin >> N)
	{
		queue q;
		for (int i = 0; i < N; i++)
		{
			int arrive, service, maxTolerate, totalWaitingTime;
			cin >> arrive >> service >> maxTolerate;
			totalWaitingTime = arrive + service;

			if (N == 1) { // debug for 1 customer only
				cout << arrive << endl;
			}
			if (i == 0) // simply push the first one into queue
			{
				q.push(totalWaitingTime);
			}
			else // not the first one
			{
				if (i != N - 1) // not the last one
				{
					// pop the gone people first
					if (arrive >= q.back()) // means all ppl should be gone, pop all
						while (q.isEmpty() == false)
							q.pop();
					else // some ppl shoule be gone, pop some of the front customer
						while (arrive >= q.getFront())
							q.pop();

					if (maxTolerate >= q.size()) // new customer could tolerate the queue length
					{
						if (arrive >= q.back()) // simply push
							q.push(totalWaitingTime);
						else // someone is waiting
							q.push(service + q.back());
					}
					else // could not tolerate, move to next customer
						continue;

				}
				else  // last one
				{
					if (arrive >= q.back()) // means all ppl should be gone, pop all
						while (q.isEmpty() == false)
							q.pop();
					else // some ppl shoule be gone, pop some of the front customer
						while (arrive >= q.getFront())
							q.pop();

					if (maxTolerate >= q.size())
					{
						if (arrive >= q.back()) // all ppl gone
							cout << arrive << endl;
						else
							cout << q.back() << endl;
					}
					else
						cout << "-1" << endl;
				}
			}
		}
		q.clear();
	}

	return 0;
}
