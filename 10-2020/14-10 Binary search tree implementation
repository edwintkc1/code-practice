#include <iostream>
#define SPACE 10
using namespace std;

class Node
{
public:
	int data;
	Node* left;
	Node* right;

	Node() :data(0), left(NULL), right(NULL)
	{
	}

	Node(int d):data(d), left(NULL), right(NULL)
	{
	}
};

class BST
{
public:
	Node* root;

	BST() : root(NULL)
	{
	}

	bool isEmpty() {
		return (root == NULL);
	}

	void insertNode(Node* n) {
		if (isEmpty())
			root = n;
		else {
			Node* temp = root;
			while (temp != NULL) {
				if (n->data == temp->data)  // duplicated data is not allowed
					return;
				else if ((n->data < temp->data) && temp->left == NULL) {
					temp->left = n;
					break;
				}
				else if (n->data < temp->data)
					temp = temp->left;
				else if ((n->data > temp->data) && temp->right == NULL) {
					temp->right = n;
					break;
				}
				else
					temp = temp->right;
			}
		}
	}

	Node* minValueOfRightSubTree(Node* n) {
		Node* current = n;
		while (n->left != NULL)  // the left most of current node has the min value
			current = current->left;
		return current;
	}

	Node* deleteNode(Node* n, int value) {  // node for start, value you want to del
		if (n == NULL)
			return n;
		else if (value < n->data) // value < n->data, go to left subtree
			n->left = deleteNode(n->left, value);
		else if (value > n->data) // value > n->data, go to right subtree
			n->right = deleteNode(n->right, value);
		else { // value == n->data
			if (n->left == NULL) { // the node has right child (return n) || has no child (return NULL)
				Node* temp = n->right;
				delete n;
				return temp;
			}
			else if (n->right == NULL) { // node has left child only
				Node* temp = n->left;
				delete n;
				return temp;
			}
			// node has 2 children
			// here we have 2 options
			// 1. find the maximum value of left subtree
			// 2. find the minimum value of right subtree
			// we use 2 
			else {
				Node* temp = minValueOfRightSubTree(n->right);
				n->data = temp->data; // just copy the data
				n->right = deleteNode(n->right, temp->data); // delete here
				// notice that we could not pass n, temp->data, because n->data == temp->data now
			}
		}
		return n;
	}

	void print2D(Node* n, int space) {
		if (n == NULL)
			return;
		space += SPACE;
		print2D(n->right, space);
		cout << endl;
		for (int i = SPACE; i < space; i++)
			cout << " ";
		cout << n->data << endl;
		print2D(n->left, space);
	}

};

int main()
{
	int option;
	BST bst;
	do
	{
		cout << "1. Insert node\n";
		cout << "2. Search node\n";
		cout << "3. Delete node\n";
		cout << "4. Print tree\n";
		cout << "5. Clear screen\n";
		cout << "0. Exit\n";

		cin >> option;
		Node* n = new Node();
		int value;

		switch (option)
		{
		case 0:
			break;
		case 1:
			cout << "Insert: ";
			cin >> value;
			n->data = value;
			bst.insertNode(n);
			break;
		case 2:
			cout << "Search: ";
			break;
		case 3:
			cout << "Value you want to delete: ";
			cin >> value;
			bst.deleteNode(bst.root,value);
			break;
		case 4:
			cout << "The tree is:\n ";
			bst.print2D(bst.root, 5);
			break;
		case 5:
			system("cls");
			break;
		default:
			break;
		}
	} while (option != 0);

	return 0;
}
