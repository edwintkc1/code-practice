#include <iostream>
#define SPACE 10
using namespace std;

class Node
{
public:
	int data;
	Node* left;
	Node* right;

	Node() :data(0), left(NULL), right(NULL)
	{
	}

	Node(int d) :data(d), left(NULL), right(NULL)
	{
	}
};

class BST
{
public:
	Node* root;

	BST() : root(NULL)
	{
	}

	bool isEmpty() {
		return (root == NULL);
	}

	void insertNode(Node* n) {
		if (isEmpty())
			root = n;
		else {
			Node* temp = root;
			while (temp != NULL) {
				if (n->data == temp->data)  // duplicated data is not allowed
					return;
				else if ((n->data < temp->data) && temp->left == NULL) {
					temp->left = n;
					break;
				}
				else if (n->data < temp->data)
					temp = temp->left;
				else if ((n->data > temp->data) && temp->right == NULL) {
					temp->right = n;
					break;
				}
				else
					temp = temp->right;
			}
		}
	}

	Node* search(int value)
	{
		if (this->root == NULL)
			return this->root;
		Node* temp = this->root;
		while (temp != NULL)
		{
			if (value == temp->data)
				return temp;
			else if (value < temp->data) // on the left
				temp = temp->left;
			else // on the right
				temp = temp->right;
		}
		return NULL;
	}

	Node* minValueOfRightSubTree(Node* n) {
		Node* current = n;
		while (n->left != NULL)  // the left most of current node has the min value
			current = current->left;
		return current;
	}

	Node* deleteNode(Node* n, int value) {  // node for start, value you want to del
		if (n == NULL)
			return n;
		else if (value < n->data) // value < n->data, go to left subtree
			n->left = deleteNode(n->left, value);
		else if (value > n->data) // value > n->data, go to right subtree
			n->right = deleteNode(n->right, value);
		else { // value == n->data
			if (n->left == NULL) { // the node has right child (return n) || has no child (return NULL)
				Node* temp = n->right;
				delete n;
				return temp;
			}
			else if (n->right == NULL) { // node has left child only
				Node* temp = n->left;
				delete n;
				return temp;
			}
			// node has 2 children
			// here we have 2 options
			// 1. find the maximum value of left subtree
			// 2. find the minimum value of right subtree
			// we use 2 
			else {
				Node* temp = minValueOfRightSubTree(n->right);
				n->data = temp->data; // just copy the data
				n->right = deleteNode(n->right, temp->data); // delete here
				// notice that we could not pass n, temp->data, because n->data == temp->data now
			}
		}
		return n;
	}

	void printPreOrder(Node* n) // middle left right
	{
		if (n == NULL)
			return;
		cout << n->data << " ";
		printPreOrder(n->left);
		printPreOrder(n->right);
	}

	void printInOrder(Node* n) // left middle right
	{
		if (n == NULL)
			return;
		printInOrder(n->left);
		cout << n->data << " ";
		printInOrder(n->right);
	}

	void printPostOrder(Node* n) // left right middle
	{
		if (n == NULL)
			return;
		printPostOrder(n->left);
		printPostOrder(n->right);
		cout << n->data << " ";
	}

	void print2D(Node* n, int space) {
		if (n == NULL)
			return;
		space += SPACE;
		print2D(n->right, space);
		cout << endl;
		for (int i = SPACE; i < space; i++)
			cout << " ";
		cout << n->data << endl;
		print2D(n->left, space);
	}

};

int main()
{
	int option;
	BST bst;
	do
	{
		cout << "1. Insert node\n";
		cout << "2. Search node\n";
		cout << "3. Delete node\n";
		cout << "4. Print tree\n";
		cout << "5. Clear screen\n";
		cout << "0. Exit\n";

		cin >> option;
		Node* n = new Node();
		int value;

		Node* temp = new Node(); // for store data
		switch (option)
		{
		case 0:
			break;
		case 1:
			cout << "Insert: ";
			cin >> value;
			n->data = value;
			bst.insertNode(n);
			break;
		case 2:
			cout << "Search: ";
			cin >> value;
			temp = bst.search(value);
			if (temp == NULL)
				cout << "Not found" << endl;
			else
				cout << "Found, data = " << temp->data << endl;
			break;
		case 3:
			cout << "Value you want to delete: ";
			cin >> value;
			bst.deleteNode(bst.root, value);
			break;
		case 4:
		{
			int op;
			do
			{
				cout << "1. Pre order" << endl;
				cout << "2. In order" << endl;
				cout << "3. Post order" << endl;
				cout << "4. Print 2D graph" << endl;
				cout << "0. Back" << endl;
				cin >> op;
				switch (op)
				{
					case 1:
						bst.printPreOrder(bst.root);
						cout << endl;
						break;
					case 2:
						bst.printInOrder(bst.root);
						cout << endl;
						break;
					case 3:
						bst.printPostOrder(bst.root);
						cout << endl;
						break;
					case 4:
						cout << "The tree is:\n ";
						bst.print2D(bst.root, 5);
						break;
					default:
						break;
				}

			} while (op != 0);
			break;
		}
		case 5:
			system("cls");
			break;
		default:
			break;
		}
	} while (option != 0);

	return 0;
}
