// C++ program to print inorder traversal 
// using stack. 
#include<bits/stdc++.h> 
using namespace std; 
  
/* A binary tree Node has data, pointer to left child 
   and a pointer to right child */
struct Node 
{ 
    int data; 
    struct Node* left; 
    struct Node* right; 
    Node (int data) 
    { 
        this->data = data; 
        left = right = NULL; 
    } 
}; 
  
/* Iterative function for inorder tree 
   traversal */
void inOrder(struct Node *root) 
{ 
    stack<Node *> s; 
    Node *curr = root; 
  
    while (curr != NULL || s.empty() == false) 
    { 
        /* Reach the left most Node of the 
           curr Node */
        while (curr !=  NULL) 
        { 
            /* place pointer to a tree node on 
               the stack before traversing 
              the node's left subtree */
            s.push(curr); 
            curr = curr->left; 
        } 
  
        /* Current must be NULL at this point */
        curr = s.top(); 
        s.pop(); 
  
        cout << curr->data << " "; 
  
        /* we have visited the node and its 
           left subtree.  Now, it's right 
           subtree's turn */
        curr = curr->right; 
  
    } /* end of while */
} 
  
/* Driver program to test above functions*/
int main() 
{ 
  
    /* Constructed binary tree is 
              1 
            /   \ 
          2      3 
        /  \ 
      4     5 
    */
    struct Node *root = new Node(1); 
    root->left        = new Node(2); 
    root->right       = new Node(3); 
    root->left->left  = new Node(4); 
    root->left->right = new Node(5); 
  
    inOrder(root); 
    return 0; 
} 

---------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
 
/* A binary tree tNode has data, a pointer to left child
   and a pointer to right child */
struct tNode {
    int data;
    struct tNode* left;
    struct tNode* right;
};
 
/* Function to traverse the binary tree without recursion
   and without stack */
void MorrisTraversal(struct tNode* root)
{
    struct tNode *current, *pre;
 
    if (root == NULL)
        return;
 
    current = root;
    while (current != NULL) {
 
        if (current->left == NULL) {
            printf("%d ", current->data);
            current = current->right;
        }
        else {
 
            /* Find the inorder predecessor of current */
            pre = current->left;
            while (pre->right != NULL
                   && pre->right != current)
                pre = pre->right;
 
            /* Make current as the right child of its
               inorder predecessor */
            if (pre->right == NULL) {
                pre->right = current;
                current = current->left;
            }
 
            /* Revert the changes made in the 'if' part to
               restore the original tree i.e., fix the right
               child of predecessor */
            else {
                pre->right = NULL;
                printf("%d ", current->data);
                current = current->right;
            } /* End of if condition pre->right == NULL */
        } /* End of if condition current->left == NULL*/
    } /* End of while */
}
 
/* UTILITY FUNCTIONS */
/* Helper function that allocates a new tNode with the
   given data and NULL left and right pointers. */
struct tNode* newtNode(int data)
{
    struct tNode* node = new tNode;
    node->data = data;
    node->left = NULL;
    node->right = NULL;
 
    return (node);
}
 
/* Driver program to test above functions*/
int main()
{
 
    /* Constructed binary tree is
            1
          /   \
         2     3
       /   \
      4     5
  */
    struct tNode* root = newtNode(1);
    root->left = newtNode(2);
    root->right = newtNode(3);
    root->left->left = newtNode(4);
    root->left->right = newtNode(5);
 
    MorrisTraversal(root);
 
    return 0;
}
1. Initialize current as root 
2. While current is not NULL
   If the current does not have left child
      a) Print currentâ€™s data
      b) Go to the right, i.e., current = current->right
   Else
      a) Find rightmost node in current left subtree OR
              node whose right child == current.
         If we found right child == current
             Go to the right, i.e. current = curent->right
         Else
             a) Make current as the right child of that rightmost 
                node we found; and 
             b) Go to this left child, i.e., current = current->left
             
             
             
---------------------------------------------------------------------------------------------------------------
// preorderpostorder

#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;
 
// Data structure to store a Binary Tree node
struct Node
{
    int data;
    Node *left, *right;
};
 
// Function to create a new binary tree node having given key
Node* newNode(int key)
{
    Node* node = new Node;
    node->data = key;
    node->left = node->right = nullptr;
 
    return node;
}
 
// Recursive function to perform inorder traversal of a binary tree
void inorder(Node* root)
{
    if (root == nullptr)
        return;
 
    inorder(root->left);
    cout << root->data << ' ';
    inorder(root->right);
}
 
// A recursive function to construct a full binary tree from given preorder
// and postorder sequence
Node* buildTree(vector<int> const &preorder, int &pIndex,
                int start, int end, unordered_map<int,int> &map)
{
    // Consider the next item from the given preorder sequence
    // This item would be the root node of subtree formed by
    // the postorder[start, end]
    Node* root = newNode(preorder[pIndex]);
 
    // increment pIndex
    pIndex++;
 
    // return if all keys are processed
    if (pIndex == preorder.size())
        return root;
 
    // find the index of next key in postorder sequence to determine the
    // boundary of left and right subtree of current root node
    int index = map[preorder[pIndex]];
 
    // fill the left and right subtree together
    if (start <= index && index + 1 <= end - 1)
    {
        // build the left subtree
        root->left = buildTree(preorder, pIndex, start, index, map);
 
        // build the right subtree
        root->right = buildTree(preorder, pIndex, index + 1, end - 1, map);
    }
 
    return root;
}
 
// Construct a full binary tree from preorder and postorder sequence
Node* buildTree(vector<int> const &preorder, vector<int> const &postorder)
{
    // map is used to efficiently find index of any element in given
    // postorder sequence
    unordered_map<int,int> map;
    for (int i = 0; i < postorder.size(); i++)
        map[postorder[i]] = i;
 
    // pIndex stores index of next node in the preorder sequence
    int pIndex = 0;
 
    // set range [start, end] for subtree formed by postorder sequence
    int start = 0;
    int end = preorder.size() - 1;
 
    // construct the binary tree and return it
    return buildTree(preorder, pIndex, start, end, map);
}
 
int main()
{
    vector<int> preorder = { 1, 2, 4, 5, 3, 6, 8, 9, 7 };
    vector<int> postorder = { 4, 5, 2, 8, 9, 6, 7, 3, 1 };
 
    Node* root = buildTree(preorder, postorder);
 
    cout << "Inorder Traversal: ";
    inorder(root);
    cout<<endl;
    return 0;
}




